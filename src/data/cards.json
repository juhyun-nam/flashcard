{
  "data": [
    {
      "subject": "OOD principle",
      "contents": [
        {
          "front": "단일 책임 원칙(SRP)",
          "back": "한 클래스는 단 한가지의 변경 이유만을 가져야 한다."
        },
        {
          "front": "개방-폐쇄 원칙(OCP)",
          "back": "소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다."
        },
        {
          "front": "리스코프 치환 원칙(LSP)",
          "back": "서브타입은 그것의 기반 타입으로 치환 가능해야 한다. (프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면 서 하위 타입의 인스턴스로 바꿀 수 있어야 한다."
        },
        {
          "front": "인터페이스 분리 원칙(ISP)",
          "back": "클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제해서는 안 된다."
        },
        {
          "front": "의존관계 역전 원칙(DIP)",
          "back": "상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다."
        }
      ]
    },
    {
      "subject": "OOP",
      "contents": [
        {
          "front": "가시성",
          "back": "한 객체가 다른 객체를 볼 수 있는 능력"
        },
        {
          "front": "객체(인스턴스)",
          "back": "어떤 일을 할 수 있는 대상. 이것은 상태와 행동, 아이덴티티가 있다."
        },
        {
          "front": "추상 연산(abstract operation)",
          "back": "추상 클래스에서 연산을 선언했으나 구현하지 않은 연산"
        },
        {
          "front": "추상 클래스",
          "back": "객체를 만들지 않는 클래스."
        },
        {
          "front": "컨테이너 클래스",
          "back": "이것으로부터 만들어진 객체는 다른 객체들의 모임을 갖는다. "
        },
        {
          "front": "컴포넌트",
          "back": "클래스들을 논리적으로 모은 것으로, 이것의 인터페이스를 통해 서비스를 제공한다."
        },
        {
          "front": "클래스",
          "back": "동일한 속성과 연산, 관계, 의미를 공유하는 객체 모임이다."
        },
        {
          "front": "타입",
          "back": "객체가 취할 수 있는 허용 값 범위와 객체에 작용할 수 있는 연산 집합을 정의한 것."
        },
        {
          "front": "프로토콜(protocol)",
          "back": "객체가 행동하고 반응하는 방법으로, 객체에 있는 정적 및 동적 외부 뷰 전체를 구성한다. 객체의 이것은 객체에 허용된 행동에 대한 포장된 모습을 정의한다."
        },
        {
          "front": "합성 관계(composition)",
          "back": "전체/부분 관계로 어떤 객체가 하나 또는 여러 객체로 구성된 것으로, 각 객체들은 전체 객체의 부분 객체로 간주된다. 전체와 부분 객체 간 생명주기가 의존적"
        },
        {
          "front": "행위(behavior)",
          "back": "객체가 동작하거나 반응하는 것을 의미하며, 상태가 변하고 메시지가 전달될 때 일어난다. 겉으로 인식되는 테스트 가능한 객체 특성이다."
        },
        {
          "front": "precondition",
          "back": "연산이 가정하는 불변 조건"
        },
        {
          "front": "postcondition",
          "back": "연산이 만족하는 불변 조건"
        },
        {
          "front": "책임",
          "back": "특정 타입이나 클래스가 같는 계약 즉, 의무. 이것은 특정한 행동을 제공하는 객체의 의무를 나타낸다."
        },
        {
          "front": "집합관계(aggregation)",
          "back": "하나의 객체가 1개 또는 여러 객체로 구성돼 있는 전체/부분 관계로, 전체를 나타내는 객체는 부분 객체들을 포함한다. 이 관계는 느슨한 포함 관계로 전체와 부분 객체의 생명 주기는 독립적이다."
        },
        {
          "front": "전이(transition)",
          "back": "한 상태에서 다른 상태로 이동함"
        },
        {
          "front": "제약(constraint)",
          "back": "의미적 조건을 표현한 수식으로, 반드시 지켜져야 한다."
        },
        {
          "front": "guard",
          "back": "이벤트에 적용한 부울 수식. 만일 참이면, 수식은 시스템 상태가 변경될 수 있게 해 준다."
        },
        {
          "front": "인터페이스(interface)",
          "back": "클래스나 객체, 컴포넌트, 복합 구조 등의 외부 뷰로서, 추상화는 강조하고 구조와 행동의 내부 모습은 제외시킨다."
        },
        {
          "front": "이벤트(event)",
          "back": "시스템 상태가 변하도록 유발시키는 것"
        },
        {
          "front": "위임(delegation)",
          "back": "한 객체에 있는 연산을 다른 객체가 대신해서 수행하는 활동"
        },
        {
          "front": "역할(role)",
          "back": "한 클래스나 객체가 다른 것과 관계를 가질 때 참여하는 목적이나 역량을 말 한다. 객체의 이것은 한 시점에 적절히 잘 정의된 여러 행동들 중 선택해서 정의된다. 이것은 특정 순간에 객체가 세상에 내미는 얼굴이다."
        },
        {
          "front": "액터(actor)",
          "back": "외부 실체가 시스템과 상호작용할 때 역할 관점에서 외부 실체를 정의한 것"
        },
        {
          "front": "아키텍처(archtecture)",
          "back": "시스템에서 컴포넌트들과 그들 간 관계에 대한 논리적 물리적 구조로서, 개발하는 동안에 여러 전략과 전술을 동원해 꾸준히 개선된다."
        },
        {
          "front": "아이덴티티(identity)",
          "back": "여러 객체 중에서 한 객체를 식별할 수 있는 객체의 본질"
        },
        {
          "front": "속성(attribute)",
          "back": "클래스 내부 구조의 일부로, 이것이 취하는 값에 따라 클래스 상태가 정해진다. 클래스에 속한 이것을 모두 모으면 클래스 구조가 된다."
        },
        {
          "front": "상태",
          "back": "객체 행동이 누적된 경과 값. 객체가 존재할 수 있는 가능한 조건 중 하나로 다른 조건들과는 정량적으로 명확히 구별됨."
        },
        {
          "front": "불변성(invariant)",
          "back": "어떤 조건에 대한 부울 수식으로, 참은 보존돼야 한다."
        },
        {
          "front": "메시지",
          "back": "한 객체에서 다른 객체를 수행하는 연산. 메시지와 메소드, 연산은 대체로 같은 의미다"
        },
        {
          "front": "구체 클래스(concrete class)",
          "back": "모든 연산이 정의돼 객체를 생성할 수 있는 클래스"
        },
        {
          "front": "객체지향 분해",
          "back": "시스템을 부분으로 나누는 프로세스로, 각 부분은 문제 영역에서 클래스나 객체에 대응된다."
        },
        {
          "front": "객체지향 분석",
          "back": "분석 방법으로서, 문제 도메인 어휘에 있는 클래스와 객체를 조사해 요구 사항을 작성한다"
        },
        {
          "front": "객체지향 프로그래밍",
          "back": "상속 관계로 클래스 계층 구조를 형성하고, 클래스에 대한 인스턴스는 객체로 표현하며, 객체가 모여 서로 협조 하며 조직을 이루게 하는 구현 방식"
        },
        {
          "front": "객체지향 설계",
          "back": "객체지향으로 분해하는 프로세스와 설계 중인 시스템을 논리모델과 물리모델 두 가지로 나타내고, 정적이고 동>적인 모델로 기술하는 표기법까지 포괄하는 방법"
        },
        {
          "front": "객체모델 구성요소",
          "back": "주: 추상화, 캡슐화, 모듈화, 계층화  부: 타입화, 동시성, 영속성"
        },
        {
          "front": "추상화",
          "back": "특정 객체의 핵심 특징만을 나타낸 것으로, 다른 종류 객체와는 구별되는 요소이고, 관찰자 관점에서 보면 개념 경계선이 상대적으로 뚜렷이 드러난다"
        },
        {
          "front": "캡슐화",
          "back": "구조와 행위로 이뤄진 추상 개념 요소를 분류하는 프로세스. 이것을 사용해 추상 개념에서 계약에 필요한 인터>페이스 부분은 나머지 구현 부분에서 분리한다."
        },
        {
          "front": "모듈성",
          "back": "응집도는 높고 결합도는 낮은 모듈로 분해된 시스템의 프로퍼티 (high cohesion, loose coupling)"
        },
        {
          "front": "계층",
          "back": "등급 즉, 서열리 있는 추상 개념"
        },
        {
          "front": "타입 검증",
          "back": "클래스가 객체에게 강제 집행하는 것으로, 타입이 다른 객체 간에는 서로 교환을 금지하든가 교환은 하더라도 >엄격히 제한된  방식으로 허용한다"
        },
        {
          "front": "병행 처리",
          "back": "능동객체와 수동객체를 구별하는 프로퍼티"
        },
        {
          "front": "영속성",
          "back": "객체에 있는 프로퍼티로서, 시간을 초월해 살고(자신의 생성자가 더 이상 존재하지 않아도 살아 있음), 공간 범 위를 넘어서 산다(자신이 생성된 주소 공간으로부터 이동해도 살아 있음)"
        }
      ]
    },
    {
      "subject": "Patterns",
      "contents": [
        {
          "front": "Abstract Factory",
          "back": "Creational Patterns. 구체적인 클래스를 지정하지 않고 관련성을 같는 객체들의 집합을 생성하거나 서로 독집적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴"
        },
        {
          "front": "Builder",
          "back": "Creational Patterns. 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴"
        },
        {
          "front": "Factory Method",
          "back": "Creational Patterns. 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브 클래스 쪽에서 내리는 패턴입니다. 팩토리 메서드 패턴에서는 클래스의 인스턴스를 만드는 시점을 서브클래스로 미룹니다. "
        },
        {
          "front": "Prototype",
          "back": "Creational Patterns. 생성할 객체의 종류를 명세하는 데에 원형이 되는 예시물을 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴"
        },
        {
          "front": "Singleton",
          "back": "Creational Patterns. 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴"
        },
        {
          "front": "Adaptor",
          "back": "Structural Patterns. 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해 줍니다."
        },
        {
          "front": "Bridge",
          "back": "Structural Patterns. 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴입니다."
        },
        {
          "front": "Composite",
          "back": "Structural Patterns. 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 합니다."
        },
        {
          "front": "Decorator",
          "back": "Structural Patterns. 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있습니다."
        },
        {
          "front": "Facade",
          "back": "Structural Patterns. 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의합니다."
        },
        {
          "front": "Flyweight",
          "back": "Structural Patterns. 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴입니다."
        },
        {
          "front": "Proxy",
          "back": "Structural Patterns. 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자(surrogate) 또는 자리채움자(placeholder)를 제공하는 패턴입니다."
        },
        {
          "front": "Chain of Responsibility",
          "back": "Behavioral Patterns. 요청을 처리할 수 있는 시회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴입니다. 요청을 받을 수 있는 객체를 연쇄적으로 묶고, 실제 요청을 처리할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달합니다."
        },
        {
          "front": "Command",
          "back": "Behavioral Patterns. 요청을 객체의 형채로 캡슐화하여 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴입니다."
        },
        {
          "front": "Interpreter",
          "back": "Behavioral Patterns. 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴입니다."
        },
        {
          "front": "Iterator",
          "back": "Behavioral Patterns. 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴입니다."
        },
        {
          "front": "Mediator",
          "back": "Behavioral Patterns. 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴입니다. 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들 사이의 소결합(loost coupling)을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다."
        },
        {
          "front": "Memento",
          "back": "Behavioral Patterns. 캡슐화를 위배하지 않은 채로 어떤 객체의 내부 상태를 잡아 내고 실체화시켜, 이후에 해당 객체가 그 상태로 되돌아올 수 있도록 하는 패턴입니다."
        },
        {
          "front": "Observer",
          "back": "Behavioral Patterns. 객체들 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다."
        },
        {
          "front": "State",
          "back": "Behavioral Patterns. 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보입니다."
        },
        {
          "front": "Strategy",
          "back": "Behavioral Patterns. 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며, 이들을 상호 교환이 가능하도록 만드는 패턴입니다. 알고리즘을 사용하는 사용자와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 합니다."
        },
        {
          "front": "Template Method",
          "back": "Behavioral Patterns. 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴입니다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게 합니다."
        },
        {
          "front": "Visitor",
          "back": "Behavioral Patterns. 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다."
        }
      ]
    },
    {
      "subject": "lang",
      "contents": [
        {
          "front": "UCHAR_MAX",
          "back": "255"
        },
        {
          "front": "USHRT_MAX",
          "back": "65535"
        },
        {
          "front": "UINT_MAX",
          "back": "4294967295"
        }
      ]
    },
    {
      "subject": "linux shortcuts",
      "contents": [
        {
          "front": "C-a / C-e",
          "back": "beginning/end-of-line"
        },
        {
          "front": "C-f / C-b",
          "back": "forward/backward-char"
        },
        {
          "front": "M-f / M-b",
          "back": "forward/backword-word"
        },
        {
          "front": "C-l",
          "back": "clear-screen"
        },
        {
          "front": "C-p / C-n",
          "back": "previous/next-history"
        },
        {
          "front": "C-r",
          "back": "reverse-search-history"
        },
        {
          "front": "C-d",
          "back": "delete-char"
        },
        {
          "front": "C-h",
          "back": "backward-delete-char"
        },
        {
          "front": "C-k",
          "back": "kill-line"
        },
        {
          "front": "C-u",
          "back": "unix-line-discard"
        },
        {
          "front": "C-w",
          "back": "unix-word-rubout"
        },
        {
          "front": "C-y",
          "back": "yank"
        },
        {
          "front": "M-y",
          "back": "yank-pop"
        },
        {
          "front": "C-_",
          "back": "undo"
        },
        {
          "front": "C-g",
          "back": "abort"
        }
      ]
    },
    {
      "subject": "Regular Expression",
      "contents": [
        {
          "front": "metacharacter BRE vs ERE",
          "back": "\\{, \\?, \\+, \\|, \\(\\)"
        },
        {
          "front": "command BRE vs ERE",
          "back": "BRE(grep, sed, vi(almost)), ERE(less, awk)"
        },
        {
          "front": "*, \\?, \\+",
          "back": "* = {0,}, \\? = {0, 1}, \\+ = {1,}"
        },
        {
          "front": "metacharacter BRE vs GLOB",
          "back": ".* = *, . = ?"
        }
      ]
    },
    {
      "subject": "Refactoring",
      "contents": [
        {
          "front": "basic",
          "back": "Extract Function, Inline Function, Extract Variable, Inline Variable, Change Function Declaration, Encapsulate Variable, Rename Variable, Introduce Parameter Object, Combine Functions into Class, Combine Functions into Transform, Split Phase, "
        },
        {
          "front": "encapsulation",
          "back": "encapsulate Record, Encapsulate Collection, Replace Primitive with Object, Replace Temp with Query, Extract Class, Inline Class, Hide Delegate, Remove Middle Man, Substitute Algorithm"
        },
        {
          "front": "moving-features",
          "back": "Move Function, Move Field, Move Statements into Function, Move Statements to Callers, Replace Inline Code with Function Call, Slide Statements, Split Loop, Replace Loop with Pipeline, Remove Dead Code"
        },
        {
          "front": "organizing-data",
          "back": "Split Variable, Rename Field, Replace Derived Variable with Query, Change Reference to Value, Change Value to Reference, Replace Magic Literal"
        },
        {
          "front": "simplify-conditional-logic",
          "back": "Decompose Conditional, Consolidate Conditional Expression, Replace Nested Conditional with Guard Clauses, Replace Conditional with Polymorphism, Introduce Special Case, Introduce Assertion, Replace Control Flag with Break"
        },
        {
          "front": "refactoring-apis",
          "back": "Separate Query from Modifier, Parametrize Function, Remove Flag Argument, Preserve Whole Object, Replace Parameter with Query, Replace Query with Parameter, Remove Setting Method, Replace Constructor with Factory Function, Replace Function with Command, Replace Command with Function, Return Modified Value, Replace Error Code with Exception, Replace Exception with Precheck"
        },
        {
          "front": "dealing-with-inheritance",
          "back": "Pull Up Method, Pull Up Field, Pull Up Constructor Body, Push Down Method, Push Down Field, Replace Type Code with Subclasses, Remove Subclass, Extract Superclass, Collapse Hierarchy, Replace Subclass with Delegate, Replace Superclass with Delegate"
        }
      ]
    }
  ]
}