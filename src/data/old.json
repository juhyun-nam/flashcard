{
  "data": [
    {
      "subject": "OOP",
      "contents": [
        {
          "front": "가시성",
          "back": "한 객체가 다른 객체를 볼 수 있는 능력"
        },
        {
          "front": "객체(인스턴스)",
          "back": "어떤 일을 할 수 있는 대상. 이것은 상태와 행동, 아이덴티티가 있다."
        },
        {
          "front": "추상 연산(abstract operation)",
          "back": "추상 클래스에서 연산을 선언했으나 구현하지 않은 연산"
        },
        {
          "front": "추상 클래스",
          "back": "객체를 만들지 않는 클래스."
        },
        {
          "front": "컨테이너 클래스",
          "back": "이것으로부터 만들어진 객체는 다른 객체들의 모임을 갖는다. "
        },
        {
          "front": "컴포넌트",
          "back": "클래스들을 논리적으로 모은 것으로, 이것의 인터페이스를 통해 서비스를 제공한다."
        },
        {
          "front": "클래스",
          "back": "동일한 속성과 연산, 관계, 의미를 공유하는 객체 모임이다."
        },
        {
          "front": "타입",
          "back": "객체가 취할 수 있는 허용 값 범위와 객체에 작용할 수 있는 연산 집합을 정의한 것."
        },
        {
          "front": "프로토콜(protocol)",
          "back": "객체가 행동하고 반응하는 방법으로, 객체에 있는 정적 및 동적 외부 뷰 전체를 구성한다. 객체의 이것은 객체에 허용된 행동에 대한 포장된 모습을 정의한다."
        },
        {
          "front": "합성 관계(composition)",
          "back": "전체/부분 관계로 어떤 객체가 하나 또는 여러 객체로 구성된 것으로, 각 객체들은 전체 객체의 부분 객체로 간주된다. 전체와 부분 객체 간 생명주기가 의존적"
        },
        {
          "front": "행위(behavior)",
          "back": "객체가 동작하거나 반응하는 것을 의미하며, 상태가 변하고 메시지가 전달될 때 일어난다. 겉으로 인식되는 테스트 가능한 객체 특성이다."
        },
        {
          "front": "precondition",
          "back": "연산이 가정하는 불변 조건"
        },
        {
          "front": "postcondition",
          "back": "연산이 만족하는 불변 조건"
        },
        {
          "front": "책임",
          "back": "특정 타입이나 클래스가 같는 계약 즉, 의무. 이것은 특정한 행동을 제공하는 객체의 의무를 나타낸다."
        },
        {
          "front": "집합관계(aggregation)",
          "back": "하나의 객체가 1개 또는 여러 객체로 구성돼 있는 전체/부분 관계로, 전체를 나타내는 객체는 부분 객체들을 포함한다. 이 관계는 느슨한 포함 관계로 전체와 부분 객체의 생명 주기는 독립적이다."
        },
        {
          "front": "전이(transition)",
          "back": "한 상태에서 다른 상태로 이동함"
        },
        {
          "front": "제약(constraint)",
          "back": "의미적 조건을 표현한 수식으로, 반드시 지켜져야 한다."
        },
        {
          "front": "guard",
          "back": "이벤트에 적용한 부울 수식. 만일 참이면, 수식은 시스템 상태가 변경될 수 있게 해 준다."
        },
        {
          "front": "인터페이스(interface)",
          "back": "클래스나 객체, 컴포넌트, 복합 구조 등의 외부 뷰로서, 추상화는 강조하고 구조와 행동의 내부 모습은 제외시킨다."
        },
        {
          "front": "이벤트(event)",
          "back": "시스템 상태가 변하도록 유발시키는 것"
        },
        {
          "front": "위임(delegation)",
          "back": "한 객체에 있는 연산을 다른 객체가 대신해서 수행하는 활동"
        },
        {
          "front": "역할(role)",
          "back": "한 클래스나 객체가 다른 것과 관계를 가질 때 참여하는 목적이나 역량을 말 한다. 객체의 이것은 한 시점에 적절히 잘 정의된 여러 행동들 중 선택해서 정의된다. 이것은 특정 순간에 객체가 세상에 내미는 얼굴이다."
        },
        {
          "front": "액터(actor)",
          "back": "외부 실체가 시스템과 상호작용할 때 역할 관점에서 외부 실체를 정의한 것"
        },
        {
          "front": "아키텍처(archtecture)",
          "back": "시스템에서 컴포넌트들과 그들 간 관계에 대한 논리적 물리적 구조로서, 개발하는 동안에 여러 전략과 전술을 동원해 꾸준히 개선된다."
        },
        {
          "front": "아이덴티티(identity)",
          "back": "여러 객체 중에서 한 객체를 식별할 수 있는 객체의 본질"
        },
        {
          "front": "속성(attribute)",
          "back": "클래스 내부 구조의 일부로, 이것이 취하는 값에 따라 클래스 상태가 정해진다. 클래스에 속한 이것을 모두 모으면 클래스 구조가 된다."
        },
        {
          "front": "상태",
          "back": "객체 행동이 누적된 경과 값. 객체가 존재할 수 있는 가능한 조건 중 하나로 다른 조건들과는 정량적으로 명확히 구별됨."
        },
        {
          "front": "불변성(invariant)",
          "back": "어떤 조건에 대한 부울 수식으로, 참은 보존돼야 한다."
        },
        {
          "front": "메시지",
          "back": "한 객체에서 다른 객체를 수행하는 연산. 메시지와 메소드, 연산은 대체로 같은 의미다"
        },
        {
          "front": "구체 클래스(concrete class)",
          "back": "모든 연산이 정의돼 객체를 생성할 수 있는 클래스"
        },
        {
          "front": "객체지향 분해",
          "back": "시스템을 부분으로 나누는 프로세스로, 각 부분은 문제 영역에서 클래스나 객체에 대응된다."
        },
        {
          "front": "객체지향 분석",
          "back": "분석 방법으로서, 문제 도메인 어휘에 있는 클래스와 객체를 조사해 요구 사항을 작성한다"
        },
        {
          "front": "객체지향 프로그래밍",
          "back": "상속 관계로 클래스 계층 구조를 형성하고, 클래스에 대한 인스턴스는 객체로 표현하며, 객체가 모여 서로 협조 하며 조직을 이루게 하는 구현 방식"
        },
        {
          "front": "객체지향 설계",
          "back": "객체지향으로 분해하는 프로세스와 설계 중인 시스템을 논리모델과 물리모델 두 가지로 나타내고, 정적이고 동>적인 모델로 기술하는 표기법까지 포괄하는 방법"
        },
        {
          "front": "객체모델 구성요소",
          "back": "주: 추상화, 캡슐화, 모듈화, 계층화  부: 타입화, 동시성, 영속성"
        },
        {
          "front": "추상화",
          "back": "특정 객체의 핵심 특징만을 나타낸 것으로, 다른 종류 객체와는 구별되는 요소이고, 관찰자 관점에서 보면 개념 경계선이 상대적으로 뚜렷이 드러난다"
        },
        {
          "front": "캡슐화",
          "back": "구조와 행위로 이뤄진 추상 개념 요소를 분류하는 프로세스. 이것을 사용해 추상 개념에서 계약에 필요한 인터>페이스 부분은 나머지 구현 부분에서 분리한다."
        },
        {
          "front": "모듈성",
          "back": "응집도는 높고 결합도는 낮은 모듈로 분해된 시스템의 프로퍼티 (high cohesion, loose coupling)"
        },
        {
          "front": "계층",
          "back": "등급 즉, 서열리 있는 추상 개념"
        },
        {
          "front": "타입 검증",
          "back": "클래스가 객체에게 강제 집행하는 것으로, 타입이 다른 객체 간에는 서로 교환을 금지하든가 교환은 하더라도 >엄격히 제한된  방식으로 허용한다"
        },
        {
          "front": "병행 처리",
          "back": "능동객체와 수동객체를 구별하는 프로퍼티"
        },
        {
          "front": "영속성",
          "back": "객체에 있는 프로퍼티로서, 시간을 초월해 살고(자신의 생성자가 더 이상 존재하지 않아도 살아 있음), 공간 범 위를 넘어서 산다(자신이 생성된 주소 공간으로부터 이동해도 살아 있음)"
        }
      ]
    },
    {
      "subject": "Refactoring",
      "contents": [
        {
          "front": "basic",
          "back": "Extract Function, Inline Function, Extract Variable, Inline Variable, Change Function Declaration, Encapsulate Variable, Rename Variable, Introduce Parameter Object, Combine Functions into Class, Combine Functions into Transform, Split Phase, "
        },
        {
          "front": "encapsulation",
          "back": "encapsulate Record, Encapsulate Collection, Replace Primitive with Object, Replace Temp with Query, Extract Class, Inline Class, Hide Delegate, Remove Middle Man, Substitute Algorithm"
        },
        {
          "front": "moving-features",
          "back": "Move Function, Move Field, Move Statements into Function, Move Statements to Callers, Replace Inline Code with Function Call, Slide Statements, Split Loop, Replace Loop with Pipeline, Remove Dead Code"
        },
        {
          "front": "organizing-data",
          "back": "Split Variable, Rename Field, Replace Derived Variable with Query, Change Reference to Value, Change Value to Reference, Replace Magic Literal"
        },
        {
          "front": "simplify-conditional-logic",
          "back": "Decompose Conditional, Consolidate Conditional Expression, Replace Nested Conditional with Guard Clauses, Replace Conditional with Polymorphism, Introduce Special Case, Introduce Assertion, Replace Control Flag with Break"
        },
        {
          "front": "refactoring-apis",
          "back": "Separate Query from Modifier, Parametrize Function, Remove Flag Argument, Preserve Whole Object, Replace Parameter with Query, Replace Query with Parameter, Remove Setting Method, Replace Constructor with Factory Function, Replace Function with Command, Replace Command with Function, Return Modified Value, Replace Error Code with Exception, Replace Exception with Precheck"
        },
        {
          "front": "dealing-with-inheritance",
          "back": "Pull Up Method, Pull Up Field, Pull Up Constructor Body, Push Down Method, Push Down Field, Replace Type Code with Subclasses, Remove Subclass, Extract Superclass, Collapse Hierarchy, Replace Subclass with Delegate, Replace Superclass with Delegate"
        }
      ]
    }
  ]
}